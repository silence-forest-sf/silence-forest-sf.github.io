<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IrisCTF2023题解</title>
    <url>/2024/01/10/IrisCTF2023%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>这是我加入r3之后第一次有输出的比赛，比赛难度不大，有些题目挺有新意的，记录一下我参与解决的题目。</p>
<h1 id="OSINT"><a href="#OSINT" class="headerlink" title="OSINT"></a>OSINT</h1><h2 id="Czech-Where"><a href="#Czech-Where" class="headerlink" title="Czech Where?"></a>Czech Where?</h2><p>开局一张图，直接喂给谷歌图片搜索</p>
<p><img src="https://raw.githubusercontent.com/silence-forest-sf/pic-bed/master/img/image.png" alt="image"></p>
<p>能找到同一地点的图片，来自一篇游记<a href="http://tabiichigo.livedoor.biz/archives/51921024.html">http://tabiichigo.livedoor.biz/archives/51921024.html</a></p>
<p>图片链接为：<a href="https://livedoor.blogimg.jp/rokitomo/imgs/4/e/4eff76c9-s.jpg">https://livedoor.blogimg.jp/rokitomo/imgs/4/e/4eff76c9-s.jpg</a></p>
<p>地点为捷克黄金巷Zlatá ulička u Daliborky</p>
<p>这篇<a href="https://www.bring-you.info/zh-tw/zlata-ulicka">文章</a>也可以佐证20号在黄金巷中，“黃金巷真的非常狹小，總長應該只有十來公尺，共有No.11到No.27十七間屋子”</p>
<p>试来试去终于出了，flag是irisctf{zlata_ulicka_u_daliborky} </p>
<p>好好好，捷克语是吧….</p>
<h1 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h1><h2 id="Where’s-skat"><a href="#Where’s-skat" class="headerlink" title="Where’s skat?"></a>Where’s skat?</h2><p>这一题一开始我以为是直接分析报文中地理相关信息，于是先研究了流量包中各种协议，一些DNS协议或者DHCP协议中可以使用地域相关字段，而在本题中不存在。后来想使用IP进行定位，只能定位到山景城的IP（但后面也证明了不是那里）。</p>
<p>Anaïs Huang师傅提出使用无线网络的SSID，根据含义明确的SSID可以有效找到大致的位置，例如</p>
<p>Morlin &lt;&#x3D;&gt; Morlin Engineering\Morlin Guest…</p>
<p>ABM Parking &lt;&#x3D;&gt; ABM Parking Services</p>
<p>Mag1str师傅则使用wigle.net这个网站利用流量中的BSSID信息准确的位置Union Station</p>
<p><img src="https://raw.githubusercontent.com/silence-forest-sf/pic-bed/master/img/image-20240110170358033.png" alt="image-20240110170358033"></p>
<p>而flag是<code>irisctf&#123;los_angeles_union_station&#125;</code></p>
<p>另外再补充一些wlan相关知识：<a href="https://forum.huawei.com/enterprise/zh/thread/580899002067599360">https://forum.huawei.com/enterprise/zh/thread/580899002067599360</a></p>
<h1 id="Foresics"><a href="#Foresics" class="headerlink" title="Foresics"></a>Foresics</h1><h2 id="Not-Just-Media"><a href="#Not-Just-Media" class="headerlink" title="Not Just Media"></a>Not Just Media</h2><p>使用potplayer播放该视频，在“属性”中的“媒体内嵌资源”项上我们可以发现怪东西</p>
<img src="https://raw.githubusercontent.com/silence-forest-sf/pic-bed/master/img/image-20240110171444649.png" alt="image-20240110171444649" style="zoom:33%;" />

<p>选中后点击“保存为其他名称”即可提取出来</p>
<p>打开预览一下就会发现存在字符替换的情况</p>
<img src="https://raw.githubusercontent.com/silence-forest-sf/pic-bed/master/img/fakefont.png" alt="image-20240110171630936" style="zoom:33%;" />

<p>那么就有以下几种思路了：</p>
<ol>
<li>提取被替换的字符</li>
<li>提取替换上去的字符</li>
<li>以这个字体重新渲染某个特定的字幕。</li>
</ol>
<p>这一题是第三者，使用这个字体重新渲染一下mkv文件中的字幕即可。</p>
<p>怎么渲染呢？在fontsee.com这个网站中上传字体后输入字幕的内容即可。</p>
<p>提取字幕也可以使用potplayer，入口在“字幕”-&gt;“保存字幕”-&gt;“另存字幕为”</p>
<p><img src="https://raw.githubusercontent.com/silence-forest-sf/pic-bed/master/img/fontsee.png" alt="image-20240110172138663"></p>
<h2 id="What-the-Beep"><a href="#What-the-Beep" class="headerlink" title="What the Beep?"></a>What the Beep?</h2><p>我愿称之为物理题。</p>
<p>思路很开门，给了四个html文件，文件名就是经纬坐标，打开后就能看到横轴为时间纵轴为分贝的折线图。</p>
<p>经过观察，记录数据如下：</p>
<table>
<thead>
<tr>
<th>位置</th>
<th>声强</th>
<th>近似</th>
</tr>
</thead>
<tbody><tr>
<td>源点</td>
<td>140dB</td>
<td>140dB</td>
</tr>
<tr>
<td>上37.310205, -120.352005</td>
<td>55.70~56.67dB</td>
<td>56dB</td>
</tr>
<tr>
<td>下37.185287, -120.292548</td>
<td>49.00~49.985dB</td>
<td>49.5</td>
</tr>
<tr>
<td>左37.258453, -120.406603</td>
<td>51.79~52.2dB</td>
<td>52dB</td>
</tr>
<tr>
<td>右37.232087, -120.262349</td>
<td>52.04~53dB</td>
<td>52dB</td>
</tr>
</tbody></table>
<p>思路就是：利用声音衰减规律计算距离，利用四个坐标计算范围，求交点。但具体数值的计算是不便的，不如转换为比例。</p>
<p><img src="https://raw.githubusercontent.com/silence-forest-sf/pic-bed/master/img/%E5%A3%B0%E9%9F%B3%E8%A1%B0%E5%87%8F%E5%85%AC%E5%BC%8F.png" alt="声音衰减公式"></p>
<p>由上述公式可以推出<code>r上:r下:r左:r右 = 2.2:1:1.4:1.4 </code></p>
<p>于是用ps模个图看看大致位置。</p>
<img src="https://raw.githubusercontent.com/silence-forest-sf/pic-bed/master/img/map.png" alt="map" style="zoom: 50%;" />

<p>可能偏差有点大，试了好多次都不对，于是心一横写了个枚举程序。</p>
<p>PS:我自己设置的参数爆破了好一会都没出，Crazy_Man随手一改就出来了，TQL，ORZ。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 左上角 37.280627, -120.325931</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 右下角 37.277058, -120.323865</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line">max_retries = <span class="number">3</span></span><br><span class="line">retry_delay = <span class="number">5</span>  <span class="comment"># 重试间隔时间（秒）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7300</span>, <span class="number">7400</span>, <span class="number">20</span>):</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5300</span>, <span class="number">5900</span>, <span class="number">20</span>):</span><br><span class="line">        connected = <span class="literal">False</span></span><br><span class="line">        retries = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> connected <span class="keyword">and</span> retries &lt; max_retries:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                p = remote(<span class="string">&quot;what-the-beep.chal.irisc.tf&quot;</span>, <span class="string">&quot;10500&quot;</span>, timeout=<span class="number">10</span>)  <span class="comment"># 设置连接超时时间为10秒</span></span><br><span class="line">                p.recvuntil(<span class="string">&quot;Input: &quot;</span>)</span><br><span class="line">                payload = <span class="string">f&quot;37.2<span class="subst">&#123;x&#125;</span>, -120.32<span class="subst">&#123;y&#125;</span>&quot;</span></span><br><span class="line">                p.sendline(payload.encode())</span><br><span class="line">                r = p.recv(<span class="number">1024</span>)</span><br><span class="line">                connected = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">f&quot;Connection error: <span class="subst">&#123;e&#125;</span>. Retrying in <span class="subst">&#123;retry_delay&#125;</span> seconds...&quot;</span>)</span><br><span class="line">                retries += <span class="number">1</span></span><br><span class="line">                time.sleep(retry_delay)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span> retries == max_retries:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Max retries reached for coordinates (<span class="subst">&#123;x&#125;</span>, <span class="subst">&#123;y&#125;</span>)&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p.close()</span><br><span class="line">            time.sleep(<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="string">&quot;Not&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> r.decode():</span><br><span class="line">                <span class="built_in">print</span>(r.decode())</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>*<span class="number">20</span>)</span><br><span class="line">                p.interactive()</span><br></pre></td></tr></table></figure>

<h2 id="Investigator-Alligator"><a href="#Investigator-Alligator" class="headerlink" title="Investigator Alligator"></a>Investigator Alligator</h2><p>背景故事就是机器被打了，加密了一些文件，用户还输入了一些东西。</p>
<p>拿到的是磁盘镜像，用7z直接解压了。</p>
<h3 id="检查用户目录"><a href="#检查用户目录" class="headerlink" title="检查用户目录"></a>检查用户目录</h3><p>在用户目录<code>\home\stephen</code>下我们发现了被加密的文件<code>encrypted.img</code>、可执行文件<code>taunt</code>和python脚本<code>rswenc.py</code></p>
<p>简单分析tauna就是提示被PWNED了，然后让输入一些内容;rswenc.py则是和指定的服务器进行交互然后利用得到的密钥加密指定文件。</p>
<p>根据题目描述，管理员记录了流量和内存镜像</p>
<p>思路就很清晰了，分析流量呗</p>
<h3 id="检查管理员目录"><a href="#检查管理员目录" class="headerlink" title="检查管理员目录"></a>检查管理员目录</h3><p>在root目录下找到.bash_history，可以确定capture下的network是受攻击时tcpdump获得的流量，使用LiME获取了内存镜像，位置为<code>\LiME\src\sample.mem</code>。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先是流量分析，结合python脚本，我们筛选出<code>ip.addr == 149.28.14.135 and tcp.port == 9281</code>的流量，发现只有一条，并且数据也是明文传输的: <code>eng0jieh7ahga7eidae6taebohhaicaeraef5ahng8ohb2Tho3ahz7ojooXeixoh0thoolung7eingietai8hiechar6ahchohn6uwah2Keid5phoil7Oovool3Quai</code></p>
<p>接下来就是编写脚本进行恢复被加密的数据了。</p>
<p>改改<code>rswenc.py</code>的ip和端口，再写个服务端发送密钥即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">data = <span class="string">&#x27;eng0jieh7ahga7eidae6taebohhaicaeraef5ahng8ohb2Tho3ahz7ojooXeixoh0thoolung7eingietai8hiechar6ahchohn6uwah2Keid5phoil7Oovool3Quai&#x27;</span></span><br><span class="line"><span class="comment"># 创建一个socket对象</span></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment"># 设置超时时间（可选）</span></span><br><span class="line">sock.settimeout(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 连接到指定的IP和端口</span></span><br><span class="line">    sock.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">4444</span>))</span><br><span class="line">    <span class="comment"># 发送数据</span></span><br><span class="line">    sock.sendall(data.encode())</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 关闭连接</span></span><br><span class="line">    sock.close()</span><br></pre></td></tr></table></figure>

<p>恢复出的数据用7z打开找到<code>data\super_duper_important_info.png</code></p>
<p><img src="https://raw.githubusercontent.com/silence-forest-sf/pic-bed/master/img/super_duper_important_info.png" alt="image-20240110191740554"></p>
<p>这是一半的flag，另一半也很容易想到就是用户输入的内容咯。</p>
<p>十六进制查看器打开<code>sample.mem</code>很容易就能找到</p>
<p><img src="https://raw.githubusercontent.com/silence-forest-sf/pic-bed/master/img/mem.png" alt="mem"></p>
<p>PS:在检查用户目录下的bash_history时会发现可疑文件<code>.cache/gunzip/gunzip</code>，这就是攻击者的🐎.</p>
]]></content>
      <tags>
        <tag>wp</tag>
      </tags>
  </entry>
  <entry>
    <title>记MapnaCTF2024的两题PLC流量</title>
    <url>/2024/01/23/%E8%AE%B0MapnaCTF2024%E7%9A%84%E4%B8%A4%E9%A2%98PLC%E6%B5%81%E9%87%8F/</url>
    <content><![CDATA[<p>这是一篇赛后复现的文章，做题的时候犯了一些错误，仅作记录警醒自己。</p>
<h1 id="Forensics-PLC-I"><a href="#Forensics-PLC-I" class="headerlink" title="Forensics&#x2F;PLC I"></a>Forensics&#x2F;PLC I</h1><blockquote>
<p>The MAPNA CERT team has identified an intrusion into the plant’s PLCs, discovering a covert message transferred to the PLC. Can you uncover this secret message?<br>MAPNA CERT 团队发现了对工厂 PLC 的入侵，发现了传输到 PLC 的秘密消息。你能揭开这个秘密信息吗？</p>
<p><strong>Files:</strong> <a href="https://web.archive.org/web/20240121173821/https://mapnactf.com/tasks/PLC_0829b4ef9780677086043add8592e996f21e0bbe.txz">PLC_0829b4ef9780677086043add8592e996f21e0bbe.txz</a></p>
</blockquote>
<p>随手翻就能看到一些奇怪的，连续的，可读的字符串。</p>
<p>掏出神奇的string,你会得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;strings plc.pcap              </span><br><span class="line">4-&quot;@</span><br><span class="line">(-#@</span><br><span class="line">&gt;-$@</span><br><span class="line">A-%@</span><br><span class="line">/-&amp;@</span><br><span class="line">I-&#x27;@</span><br><span class="line">/-(@</span><br><span class="line">I-)@</span><br><span class="line">/-*@</span><br><span class="line">I-+@</span><br><span class="line">/-,@</span><br><span class="line">I--@</span><br><span class="line">3:Ld_4lW4 &lt;---</span><br><span class="line">6ES7 151-8AB01-0AB0 </span><br><span class="line">/-.@</span><br><span class="line">E-/@</span><br><span class="line">/-0@</span><br><span class="line">I-1@</span><br><span class="line">/-2@</span><br><span class="line">I-3@</span><br><span class="line">IM151-8 PN/DP CPU</span><br><span class="line">/-4@</span><br><span class="line">5:3__PaAD	&lt;---</span><br><span class="line">E-5@</span><br><span class="line">/-6@</span><br><span class="line">1:MAPNA&#123;y    &lt;---</span><br><span class="line">E-7@</span><br><span class="line">/-8@</span><br><span class="line">4:yS__CaR	&lt;---</span><br><span class="line">O-9@</span><br><span class="line"> #      !</span><br><span class="line">/-:@</span><br><span class="line">E-;@</span><br><span class="line">/-&lt;@</span><br><span class="line">6:d1n9!!&#125;	&lt;---</span><br><span class="line">E-=@</span><br><span class="line">Y3td</span><br><span class="line">/-&gt;@</span><br><span class="line">2:0U_sHOu 	&lt;---</span><br><span class="line">(-?@</span><br></pre></td></tr></table></figure>

<p>善良的出题人还告诉了我们顺序！所以flag是<code>MAPNA&#123;y0U_sHOuLd_4lW4yS__CaR3__PaADd1n9!!&#125;</code></p>
<h1 id="Forensics-PLC-Ⅱ"><a href="#Forensics-PLC-Ⅱ" class="headerlink" title="Forensics&#x2F;PLC Ⅱ"></a>Forensics&#x2F;PLC Ⅱ</h1><blockquote>
<p>After extensive investigations, the MAPNA forensics team discovered that the attackers attempted to manipulate the PLC time. Please identify the precise time in the following format: year:month:day:hour:minute:second:millisecond. The flag is MAPNA{sha256(datetime)}.<br>经过广泛的调查，MACNA取证团队发现攻击者试图操纵PLC时间。请按以下格式标识精确时间：年：月：日：小时：分钟：秒：毫秒。标志为 MAPNA{sha256（datetime）}。</p>
<p><strong>Files:</strong> <a href="https://web.archive.org/web/20240121173821/https://mapnactf.com/tasks/PLC_0829b4ef9780677086043add8592e996f21e0bbe.txz">PLC_0829b4ef9780677086043add8592e996f21e0bbe.txz</a></p>
</blockquote>
<p>拿到流量包发现全部都是TCP流量，显然应该就提取data数据，然后分析具体是什么协议了。</p>
<p>题目的名字的为PLC，这意味着这是一道工控设备的流量题，通过第29条流量我们甚至可以直接发现设备的型号为：IM151-8 PN&#x2F;DP CPU，这是西门子旗下的一款设备。</p>
<p><img src="https://raw.githubusercontent.com/silence-forest-sf/pic-bed/master/img/image-20240123104911593.png" alt="image-20240123104911593"></p>
<p>循着这个思路下去就是分析这款设备如何修改时间，这里我走进了一个误区，去翻阅了这款cpu的<a href="https://cache.industry.siemens.com/dl/files/312/47409312/att_78878/v1/et200s_im151_8_pn_dp_cpu_operating_instructions_zh-CHS_zh-CHS.pdf">手册</a>找到了它”使用 PROFINET 进行时间同步”。仔细研究profinet这个协议之后我卡住了，因为它和TCP没有毛关系。</p>
<p>事实上这个是相对底层的东西，不是很重要。（这里我也问了LLM，它也把我往这方面去引导了T^T）我们需要知道的是：</p>
<ol>
<li><strong>IM151-8是什么</strong>：西门子工业自动化领域的产品系列之一，属于西门子的S7-1500系列。</li>
<li><strong>怎么使用它</strong>：STEP 7是用于编程、配置和维护SIMATIC S7控制器的软件工具。</li>
<li><strong>工控软件的协议是什么</strong>：S7 协议是 SIEMENS S7系列产品之间通讯使用的标准协议</li>
</ol>
<p>因此S7协议才是这里的流量真正归属的协议。</p>
<p>再介绍一下，来自sealldev的智慧，在他们的wp中他们截取了tcp.data起始部分<code>03000016</code>使用github的code search功能找到了相关的脚本，进而确定了协议</p>
<p><img src="https://raw.githubusercontent.com/silence-forest-sf/pic-bed/master/img/search_result_on_github0123.png" alt="image-20240123112840406"></p>
<p>wireshark wiki在<a href="https://wiki.wireshark.org/S7comm">S7comm</a>中提到了<a href="https://wiki.wireshark.org/uploads/__moin_import__/attachments/SampleCaptures/s7comm_reading_setting_plc_time.pcap">设置时间的例子</a></p>
<p>在示例中我们可以找到设置时间（set time）的43号流量，并且关注到表示设置时间的特征数值：<code>4702</code>（如图所示，4代表请求，7代表时间函数，02代表设置时间的子函数）</p>
<p><img src="https://raw.githubusercontent.com/silence-forest-sf/pic-bed/master/img/image-20240123122837950.png" alt="image-20240123122837950"></p>
<p>因此我们在题目附件plc.pcap的分组字节流中进行十六进制值的搜索即可。</p>
<p>以下是我的搜索结果：</p>
<p><img src="https://raw.githubusercontent.com/silence-forest-sf/pic-bed/master/img/image-20240123123238801.png" alt="image-20240123123238801"></p>
<p>时间戳就是<code>00202309211959599490</code>，解析结果是<code>2023:09:21:19:59:29:949</code>，依照题目要求进行sha256即可。</p>
<h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><h2 id="S7-Timestamp"><a href="#S7-Timestamp" class="headerlink" title="S7 Timestamp"></a>S7 Timestamp</h2><p>以题目PLCⅡ中的<code>00202309211959599490</code>为例进行解析</p>
<table>
<thead>
<tr>
<th>位置</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>0x00</td>
<td>保留，一般为0x00</td>
<td>00</td>
</tr>
<tr>
<td>0x01</td>
<td>年1</td>
<td>20</td>
</tr>
<tr>
<td>0x02</td>
<td>年2</td>
<td>23</td>
</tr>
<tr>
<td>0x03</td>
<td>月</td>
<td>09</td>
</tr>
<tr>
<td>0x04</td>
<td>日</td>
<td>21</td>
</tr>
<tr>
<td>0x05</td>
<td>时</td>
<td>19</td>
</tr>
<tr>
<td>0x06</td>
<td>分</td>
<td>59</td>
</tr>
<tr>
<td>0x07</td>
<td>秒</td>
<td>59</td>
</tr>
<tr>
<td>0x08~0x0a</td>
<td>毫秒（逆序）</td>
<td>0949</td>
</tr>
</tbody></table>
<h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><ul>
<li><a href="https://ctf.krauq.com/mapna-ctf-2024">krauq’s wp</a></li>
<li><a href="https://seall.dev/posts/mapnactf2024#forensicsplc-ii--11-solves">seall’s wp</a></li>
<li><a href="https://wiki.wireshark.org/S7comm">wirshark wiki-S7comm</a></li>
</ul>
<h2 id="小反思"><a href="#小反思" class="headerlink" title="小反思"></a>小反思</h2><ol>
<li>对流量的特征进行搜索，最简单的方式就是截取数据头部</li>
<li>别太相信LLM，他们鬼话太多了。</li>
<li>匍匐在伟大的github code search之下吧！</li>
</ol>
]]></content>
      <tags>
        <tag>PLC,流量分析</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向任务下大模型的简单对比</title>
    <url>/2024/01/05/%E9%80%86%E5%90%91%E4%BB%BB%E5%8A%A1%E4%B8%8B%E5%A4%A7%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<blockquote>
<p>进行这个实验缘起于看到了宝玉xp分享的技术文章”<a href="https://baoyu.io/translations/openai/openai-prompt-engineering-guides?continueFlag=500555d146d28e174849c3962a373fe0">OpenAI 官方提示工程指南 [译]</a>“， 又想起了WPeace分享的ida插件”WPeChatGPT“<br>PS：我是穷逼所以目前使用都是免费的模型<br>PS：文章还没有写完，清华✌就推出了逆向大模型，可惜我没有申请~~&gt;_&lt;~~</p>
</blockquote>
<h1 id="约定"><a href="#约定" class="headerlink" title="约定"></a>约定</h1><p>根据提示工程指南我设计的promot如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">你需要扮演一位资深的软件逆向工程师并执行以下任务：</span><br><span class="line">1.将汇编代码或字节码提升为高级语言如C++或C（如果给出的是伪代码则忽略该步骤）</span><br><span class="line">2.根据1中提升出的代码或直接得到的代码在100字内归纳总结代码的功能</span><br><span class="line">3.结合代码和代码的功能猜测代码可能的函数名和出自哪个库</span><br><span class="line">其他说明：</span><br><span class="line">1. 你需要分析的代码将使用“`”符号进行包裹，例如void a(int v1)....`</span><br><span class="line">2. 理解任务后，请回答“明白&quot;</span><br></pre></td></tr></table></figure>

<p>选取的逆向代码为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请分析以下代码：</span><br><span class="line">`.text:00000001400145B0 ; uintptr_t sub_1400145B0()</span><br><span class="line">.text:00000001400145B0 sub_1400145B0   proc near </span><br><span class="line">.text:00000001400145B0 var_18          = qword ptr -18h</span><br><span class="line">.text:00000001400145B0</span><br><span class="line">.text:00000001400145B0                 sub     rsp, 38h</span><br><span class="line">.text:00000001400145B4                 mov     rax, 2B992DDFA232h</span><br><span class="line">.text:00000001400145BE                 cmp     cs:__security_cookie, rax</span><br><span class="line">.text:00000001400145C5                 jz      short loc_1400145DA</span><br><span class="line">.text:00000001400145C7                 mov     rax, cs:__security_cookie</span><br><span class="line">.text:00000001400145CE                 not     rax</span><br><span class="line">.text:00000001400145D1                 mov     cs:qword_14001E080, rax</span><br><span class="line">.text:00000001400145D8                 jmp     short loc_14001461F</span><br><span class="line">.text:00000001400145DA</span><br><span class="line">.text:00000001400145DA loc_1400145DA:                          ; CODE XREF: sub_1400145B0+15↑j</span><br><span class="line">.text:00000001400145DA                 call    sub_1400144C0</span><br><span class="line">.text:00000001400145DF                 mov     [rsp+38h+var_18], rax</span><br><span class="line">.text:00000001400145E4                 mov     rax, 2B992DDFA232h</span><br><span class="line">.text:00000001400145EE                 cmp     [rsp+38h+var_18], rax</span><br><span class="line">.text:00000001400145F3                 jnz     short loc_140014604</span><br><span class="line">.text:00000001400145F5                 mov     rax, 2B992DDFA233h</span><br><span class="line">.text:00000001400145FF                 mov     [rsp+38h+var_18], rax</span><br><span class="line">.text:0000000140014604</span><br><span class="line">.text:0000000140014604 loc_140014604:                          ; CODE XREF: sub_1400145B0+43↑j</span><br><span class="line">.text:0000000140014604                 mov     rax, [rsp+38h+var_18]</span><br><span class="line">.text:0000000140014609                 mov     cs:__security_cookie, rax</span><br><span class="line">.text:0000000140014610                 mov     rax, [rsp+38h+var_18]</span><br><span class="line">.text:0000000140014615                 not     rax</span><br><span class="line">.text:0000000140014618                 mov     cs:qword_14001E080, rax</span><br><span class="line">.text:000000014001461F</span><br><span class="line">.text:000000014001461F loc_14001461F:  </span><br><span class="line">.text:000000014001461F                 add     rsp, 38h</span><br><span class="line">.text:0000000140014623                 retn`</span><br></pre></td></tr></table></figure>

<p>本次评测参与的模型有：</p>
<table>
<thead>
<tr>
<th>模型</th>
<th>文心一言</th>
<th>通义千问</th>
<th>ChatGPT3.5</th>
</tr>
</thead>
<tbody><tr>
<td>版本</td>
<td>2.5.2</td>
<td>2.1.1</td>
<td>text-davinci-002-render-sha</td>
</tr>
</tbody></table>
<h1 id="对比大模型的反编译能力"><a href="#对比大模型的反编译能力" class="headerlink" title="对比大模型的反编译能力"></a>对比大模型的反编译能力</h1><p><strong>文心一言的表现</strong></p>
<p><img src="https://raw.githubusercontent.com/silence-forest-sf/pic-bed/master/img/%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80%E5%8F%8D%E7%BC%96%E8%AF%91.png" alt="image-20231227202743069"></p>
<p><strong>通义千问的表现</strong></p>
<p><img src="https://raw.githubusercontent.com/silence-forest-sf/pic-bed/master/img/%E9%80%9A%E4%B9%89%E5%8D%83%E9%97%AE%E5%8F%8D%E7%BC%96%E8%AF%91.png" alt="image-20231227202836898"></p>
<p><strong>ChatGPT3.5的表现</strong></p>
<p><img src="https://raw.githubusercontent.com/silence-forest-sf/pic-bed/master/img/ChatGPT%E5%8F%8D%E7%BC%96%E8%AF%91.png" alt="image-20231227203058570"></p>
<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>首先，分析我们的任务要求。我们的任务要求包括三部分，一是对汇编代码的进行提升，二是总结代码功能，三是推测函数的来源，细节上我们还要求“用少于等于100字”进行归纳总结。</p>
<p>三个模型的完成情况如下(<code>-</code>表示没有识别到任务，<code>0</code>表示未完成，<code>0.5</code>表示完成的一般，<code>1</code>表示基本完成)：</p>
<table>
<thead>
<tr>
<th></th>
<th align="center">文心一言</th>
<th align="center">通义千问</th>
<th align="center">ChatGPT3.5</th>
</tr>
</thead>
<tbody><tr>
<td>提升</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">0</td>
</tr>
<tr>
<td>总结</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
<tr>
<td>推测</td>
<td align="center">-</td>
<td align="center">0.5</td>
<td align="center">0.5</td>
</tr>
<tr>
<td>100字内</td>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">1</td>
</tr>
</tbody></table>
<p>三个模型基本都能做到对代码的总结（虽然接近对汇编代码的逐行翻译了），也能控制字数在指定范围内，但两个国产模型没有识别到提升任务，此外文心一言还没有完成推测任务。可能由于信息缺失，导致推测任务对于大模型而言比较困难，所以我进行了补充信息的尝试，补充的信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">接下来我将补充关于函数sub_1400144C0的内容。补充完全后，你需要重新分析sub_1400145B0函数。</span><br><span class="line">.text:1400144C0 sub_1400144C0   proc near               </span><br><span class="line">.text:1400144C0                 push    rdi</span><br><span class="line">.text:1400144C2                 sub     rsp, 40h</span><br><span class="line">.text:1400144C6                 lea     rax, [rsp+48h+SystemTimeAsFileTime]</span><br><span class="line">.text:1400144CB                 mov     rdi, rax</span><br><span class="line">.text:1400144CE                 xor     eax, eax</span><br><span class="line">.text:1400144D0                 mov     ecx, 8</span><br><span class="line">.text:1400144D5                 rep stosb</span><br><span class="line">.text:1400144D7                 lea     rcx, [rsp+48h+SystemTimeAsFileTime] </span><br><span class="line">.text:1400144DC                 call    cs:GetSystemTimeAsFileTime</span><br><span class="line">.text:1400144E2                 mov     rax, qword ptr [rsp+48h+SystemTimeAsFileTime.dwLowDateTime]</span><br><span class="line">.text:1400144E7                 mov     [rsp+48h+var_28], rax</span><br><span class="line">.text:1400144EC                 call    cs:GetCurrentThreadId</span><br><span class="line">.text:1400144F2                 mov     eax, eax</span><br><span class="line">.text:1400144F4                 mov     rcx, [rsp+48h+var_28]</span><br><span class="line">.text:1400144F9                 xor     rcx, rax</span><br><span class="line">.text:1400144FC                 mov     rax, rcx</span><br><span class="line">.text:1400144FF                 mov     [rsp+48h+var_28], rax</span><br><span class="line">.text:140014504                 call    cs:GetCurrentProcessId</span><br><span class="line">.text:14001450A                 mov     eax, eax</span><br><span class="line">.text:14001450C                 mov     rcx, [rsp+48h+var_28]</span><br><span class="line">.text:140014511                 xor     rcx, rax</span><br><span class="line">.text:140014514                 mov     rax, rcx</span><br><span class="line">.text:140014517                 mov     [rsp+48h+var_28], rax</span><br><span class="line">.text:14001451C                 lea     rcx, [rsp+48h+PerformanceCount] </span><br><span class="line">.text:140014521                 call    cs:QueryPerformanceCounter</span><br><span class="line">.text:140014527                 mov     eax, dword ptr [rsp+48h+PerformanceCount]</span><br><span class="line">.text:14001452B                 shl     rax, 20h</span><br><span class="line">.text:14001452F                 xor     rax, qword ptr [rsp+48h+PerformanceCount]</span><br><span class="line">.text:140014534                 mov     rcx, [rsp+48h+var_28]</span><br><span class="line">.text:140014539                 xor     rcx, rax</span><br><span class="line">.text:14001453C                 mov     rax, rcx</span><br><span class="line">.text:14001453F                 mov     [rsp+48h+var_28], rax</span><br><span class="line">.text:140014544                 lea     rax, [rsp+48h+var_28]</span><br><span class="line">.text:140014549                 mov     rcx, [rsp+48h+var_28]</span><br><span class="line">.text:14001454E                 xor     rcx, rax</span><br><span class="line">.text:140014551                 mov     rax, rcx</span><br><span class="line">.text:140014554                 mov     [rsp+48h+var_28], rax</span><br><span class="line">.text:140014559                 mov     rax, 0FFFFFFFFFFFFh</span><br><span class="line">.text:140014563                 mov     rcx, [rsp+48h+var_28]</span><br><span class="line">.text:140014568                 and     rcx, rax</span><br><span class="line">.text:14001456B                 mov     rax, rcx</span><br><span class="line">.text:14001456E                 mov     [rsp+48h+var_28], rax</span><br><span class="line">.text:140014573                 mov     rax, [rsp+48h+var_28]</span><br><span class="line">.text:140014578                 add     rsp, 40h</span><br><span class="line">.text:14001457C                 pop     rdi</span><br><span class="line">.text:14001457D                 retn</span><br></pre></td></tr></table></figure>

<p>囿于篇幅，不展示具体的结果仅作口头描述。</p>
<p>三个模型均首先提升了新补充的函数，并没有重新分析目标函数，总结功能上更加具体了一些，但仍不能推测函数的出处，需要指出的是ChatGPT的没有真正提升至高级语言。</p>
<h1 id="对比不同大模型的推测分析能力"><a href="#对比不同大模型的推测分析能力" class="headerlink" title="对比不同大模型的推测分析能力"></a>对比不同大模型的推测分析能力</h1><p>在本part中，我尝试直接提供ida pro反编译的结果给大模型，让他们重新分析，promot与上一个实验一致。</p>
<p>提供的反编译代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">sub_1400144C0</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> __int64 v1; <span class="comment">// [rsp+20h] [rbp-28h] BYREF</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">FILETIME</span> <span class="title">SystemTimeAsFileTime</span>;</span> <span class="comment">// [rsp+28h] [rbp-20h] BYREF</span></span><br><span class="line">  LARGE_INTEGER PerformanceCount; <span class="comment">// [rsp+30h] [rbp-18h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(&amp;SystemTimeAsFileTime, <span class="number">0</span>, <span class="keyword">sizeof</span>(SystemTimeAsFileTime));</span><br><span class="line">  GetSystemTimeAsFileTime(&amp;SystemTimeAsFileTime);</span><br><span class="line">  v1 = (<span class="type">unsigned</span> __int64)SystemTimeAsFileTime;</span><br><span class="line">  v1 ^= GetCurrentThreadId();</span><br><span class="line">  v1 ^= GetCurrentProcessId();</span><br><span class="line">  QueryPerformanceCounter(&amp;PerformanceCount);</span><br><span class="line">  <span class="keyword">return</span> ((<span class="type">unsigned</span> __int64)&amp;v1 ^ PerformanceCount.QuadPart ^ ((<span class="type">unsigned</span> __int64)PerformanceCount.LowPart &lt;&lt; <span class="number">32</span>) ^ v1) &amp; <span class="number">0xFFFFFFFFFFFF</span>i64;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">uintptr_t</span> <span class="title function_">sub_1400145B0</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uintptr_t</span> result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v1; <span class="comment">// [rsp+20h] [rbp-18h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( _security_cookie == <span class="number">0x2B992DDFA232</span>i64 )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = sub_1400144C0();</span><br><span class="line">    <span class="keyword">if</span> ( v1 == <span class="number">0x2B992DDFA232</span>i64 )</span><br><span class="line">      v1 = <span class="number">0x2B992DDFA233</span>i64;</span><br><span class="line">    _security_cookie = v1;</span><br><span class="line">    result = ~v1;</span><br><span class="line">    qword_14001E080 = ~v1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = ~_security_cookie;</span><br><span class="line">    qword_14001E080 = ~_security_cookie;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>文心一言的表现</strong></p>
<p><img src="https://raw.githubusercontent.com/silence-forest-sf/pic-bed/master/img/%E6%96%87%E5%BF%83%E4%B8%80%E8%A8%80%E7%8C%9C%E5%87%BD%E6%95%B0.png" alt="image-20231227221124047"></p>
<p><strong>通义千问的表现</strong></p>
<p><img src="https://raw.githubusercontent.com/silence-forest-sf/pic-bed/master/img/%E9%80%9A%E4%B9%89%E5%8D%83%E9%97%AE%E7%8C%9C%E5%87%BD%E6%95%B0.png" alt="image-20231227221119523"></p>
<p><strong>ChatGPT3.5的表现</strong></p>
<p><img src="https://raw.githubusercontent.com/silence-forest-sf/pic-bed/master/img/ChatGPT%E7%8C%9C%E5%87%BD%E6%95%B0.png" alt="image-20231227222043631"></p>
<h2 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h2><p>三个模型的完成情况如下(<code>-</code>表示没有识别到任务，<code>0</code>表示未完成，<code>0.5</code>表示完成的一般，<code>1</code>表示基本完成)：</p>
<table>
<thead>
<tr>
<th></th>
<th align="center">文心一言</th>
<th align="center">通义千问</th>
<th align="center">ChatGPT3.5</th>
</tr>
</thead>
<tbody><tr>
<td>总结</td>
<td align="center">1</td>
<td align="center">0.5</td>
<td align="center">1</td>
</tr>
<tr>
<td>推测</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0.5</td>
</tr>
</tbody></table>
<p>三个模型的表现各有亮点，文心一言和ChatGPT3.5都在总结中指出了函数用于防御缓冲区溢出；在预测部分中，通义千问给出了函数名（实际查询后发现给出的函数名是错误的，但有一定参考价值），而ChatGPT注意到了该函数和Windows相关。</p>
<h2 id="以WPeChatGPT插件为例，对比不同提示的效果"><a href="#以WPeChatGPT插件为例，对比不同提示的效果" class="headerlink" title="以WPeChatGPT插件为例，对比不同提示的效果"></a>以WPeChatGPT插件为例，<strong>对比不同提示的效果</strong></h2><p>通过阅读WPeChatGPT的源码，我将其逆向部分使用的Promot提取如下（原插件中还设计了漏洞分析和利用的promot）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下面是一个C语言伪代码函数，分别分析该函数的预期目的、参数的作用、详细功能，最后取一个新的函数名字。（用简体中文回答我，并且回答开始前加上&#x27;---GPT_START---&#x27;字符串结束后加上&#x27;---GPT_END---&#x27;字符串</span><br><span class="line">结合该程序的函数调用结构及其所包含的字符串，猜测其运行目的及功能。</span><br><span class="line">请再仔细分析后告诉我该程序的运行目的及大概功能。</span><br></pre></td></tr></table></figure>

<p>这个提示包括两部分，第一部分是逐步分析，第二部分是总结（反复确认是为了减少错误）。</p>
<p>让我发送测试中的伪C代码，以下是Chat-GPT3.5 Turbo的响应</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># PART 1</span><br><span class="line">---GPT_START---</span><br><span class="line">这段C语言伪代码实际上是两个函数的定义，我们分别来分析它们的预期目的、参数的作用以及详细功能。</span><br><span class="line"></span><br><span class="line">第一个函数（sub_1400144C0）的预期目的：</span><br><span class="line">该函数的预期目的是生成一个无符号整数作为随机数或者用作特定目的的标识符。</span><br><span class="line"></span><br><span class="line">参数的作用：</span><br><span class="line">该函数没有任何参数。</span><br><span class="line"></span><br><span class="line">详细功能：</span><br><span class="line"></span><br><span class="line">创建一个无符号整数变量 v1，并初始化为 0。</span><br><span class="line">使用 GetSystemTimeAsFileTime 函数获取当前系统时间，并将其存储在 SystemTimeAsFileTime 结构体中。</span><br><span class="line">将 SystemTimeAsFileTime 的值转换为无符号整数，并存储在 v1 中。</span><br><span class="line">对 v1 进行位异或操作，依次与当前线程 ID 和当前进程 ID 进行异或操作。</span><br><span class="line">使用 QueryPerformanceCounter 函数获取性能计数器的值，并将其存储在 PerformanceCount 变量中。</span><br><span class="line">将 v1 与 PerformanceCount.QuadPart 进行位异或操作，然后将 PerformanceCount.LowPart 左移 32 位与其异或，再将 v1 与结果进行异或。</span><br><span class="line">将结果与 0xFFFFFFFFFFFF 进行位与操作，以保留低 48 位的值。</span><br><span class="line">返回结果作为函数的输出。</span><br><span class="line">第二个函数（sub_1400145B0）的预期目的：</span><br><span class="line">该函数的预期目的是生成一个安全的随机数或者用作特定目的的标识符，并更新安全 cookie 的值。</span><br><span class="line"></span><br><span class="line">参数的作用：</span><br><span class="line">该函数没有任何参数。</span><br><span class="line"></span><br><span class="line">详细功能：</span><br><span class="line"></span><br><span class="line">检查全局变量 _security_cookie 的值是否等于 0x2B992DDFA232i64。</span><br><span class="line">如果 _security_cookie 的值等于 0x2B992DDFA232i64，则执行以下步骤：</span><br><span class="line">调用 sub_1400144C0 函数获取一个随机数或标识符，并将其存储在 v1 中。</span><br><span class="line">如果 v1 的值等于 0x2B992DDFA232i64，则将其更新为 0x2B992DDFA233i64。</span><br><span class="line">将 v1 的值赋给 _security_cookie 和 qword_14001E080。</span><br><span class="line">将 v1 的按位取反作为函数的返回值。</span><br><span class="line">如果 _security_cookie 的值不等于 0x2B992DDFA232i64，则将 _security_cookie 的按位取反赋给 result 和 qword_14001E080。</span><br><span class="line">返回 result 作为函数的输出。</span><br><span class="line">根据这两个函数的功能，可以将第一个函数命名为 generateRandomIdentifier，将第二个函数命名为 updateSecurityCookie。</span><br><span class="line"></span><br><span class="line">---GPT_END---</span><br><span class="line"></span><br><span class="line"># PART 2</span><br><span class="line">过进一步分析，我可以给出更准确的关于该程序的运行目的和大概功能的推测。</span><br><span class="line"></span><br><span class="line">该程序的运行目的：</span><br><span class="line">该程序的运行目的是生成一个安全的随机数或标识符，用于加强程序的安全性和防止恶意攻击，特别是针对缓冲区溢出等安全漏洞的攻击。</span><br><span class="line"></span><br><span class="line">该程序的大概功能：</span><br><span class="line"></span><br><span class="line">sub_1400144C0 函数用于生成一个随机数或标识符。</span><br><span class="line"></span><br><span class="line">首先，该函数获取当前系统时间，并将其转换为一个无符号整数。</span><br><span class="line">然后，与当前线程 ID 和当前进程 ID 进行异或运算，以增加随机性。</span><br><span class="line">最后，使用性能计数器的值进行一系列位异或操作，并将生成的随机数或标识符返回。</span><br><span class="line">sub_1400145B0 函数用于更新安全 cookie 的值。</span><br><span class="line"></span><br><span class="line">首先，该函数检查全局变量 _security_cookie 的值是否等于特定的常量（0x2B992DDFA232i64）来验证安全性。</span><br><span class="line">如果 _security_cookie 的值等于特定常量，则调用 sub_1400144C0 函数生成一个新的随机数或标识符，并将其赋给 _security_cookie 和另一个全局变量 qword_14001E080。</span><br><span class="line">如果 _security_cookie 的值不等于特定常量，则将 _security_cookie 按位取反，并赋给 result 和 qword_14001E080。</span><br><span class="line">综上所述，该程序的大概功能是生成用于加强程序安全性的随机数或标识符，并通过更新安全 cookie 的值来保护程序免受潜在的攻击。这种机制可以增加程序的安全性，防止某些类型的攻击，如缓冲区溢出。但具体的功能和用途仍需要查看完整的源代码或相关文档以进行确认。</span><br></pre></td></tr></table></figure>

<p>可能是由于目标代码比较简单，并没有比较出明显差距。但WPeChatGPT所使用的提示也启发了我们：</p>
<ol>
<li><strong>还应该让大模型关注参数和返回值</strong></li>
<li><strong>逐步完成任务，先仔细分析，再综合分析。</strong></li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li><p>大模型在逆向任务中大有用处，但也存在能力边界</p>
<ol>
<li><p>大模型目前不能帮助我们完成反编译工作，IDA Pro这样的专业逆向工具还是非常强力的。</p>
</li>
<li><p>大模型具有丰富的知识，其在函数名恢复和函数库推测上有优势。</p>
</li>
<li><p>大模型对函数功能的总结可以帮助我们快速理解函数功能或对我们的猜测工作给予指引，这将节省我们非常多的时间。</p>
</li>
</ol>
</li>
<li><p>合理设计Promot‘</p>
<ol>
<li>让模型扮演一个角色</li>
<li>指引大模型分步骤完成任务</li>
<li>设计良好的格式</li>
<li>补充必要的知识&#x2F;上下文：在使用时应该提供伪C代码并尽量补充涉及的函数的实现。</li>
</ol>
</li>
<li><p>逆向任务中ChatGPT3.5 &gt; 通义千问  &gt; 文心一言</p>
</li>
</ol>
]]></content>
  </entry>
</search>
